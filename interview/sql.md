来自https://github.com/forthespada/InterviewGuide/blob/main/Doc/Knowledge/数据库/MySQL/MySQL.md#数据库第一部分
https://www.iamshuaidi.com/1402.html
# 基础
## MySQL中有四种索引类型
- BTREE： mysql默认索引类型。将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。
- HASH ： 由于HASH的唯一及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,但是，只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
- FULLTEXT ：即为全文索引，目前只有MyISAM引擎支持。
- RTREE ：RTREE在MySQL很少使用，仅支持geometry数据类型。相对于BTREE，RTREE的优势在于范围查找。
## 为什么MySQL索引适用用B+树而不用hash表和B树？
- 利用Hash需要把数据全部**加载到内存中**，如果数据量大，是一件很**消耗内存**的事，而采用B+树，是基于**按照节点分段加载，由此减少内存消耗**。
- 和业务场景有段，**对于唯一查找**（查找一个值），Hash确实更快，**但数据库中经常查询多条数据**，这时候由于B+数据的有序性，与叶子节点又有链表相连，他的查询效率会比Hash快的多。
- b+树的**非叶子节点不保存数据**，**只保存子树的临界值**（最大或者最小），所以同样大小的节点，**b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少**。
## 谈谈你对 B+ 树的理解？
1. 在 B+ 树中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。
2. 进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。
## 什么时候需要建立数据库索引呢？
1. 在最频繁使用的、用以缩小查询范围的字段上建立索引；
2. 在频繁使用的、需要排序的字段上建立索引。
## 覆盖索引
如果一个索引包含了满足查询语句中字段与条件的数据就叫做覆盖索引。
我们知道在InnoDB存储引 擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就 会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！
## 主键、超键、候选键、外键是什么？
超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键。
候选键(candidate key):不含有多余属性的超键称为候选键。
主键(primary key):用户选作元组标识的一个候选键程序主键。
外键:在一个表中存在的另一个表的主键称为此表的外键。
## 数据库三大范式
1. 第一范式：字段不可分.原子性。 字段不可再分,否则就不是关系数据库;；
2. 第二范式：非主键字段依赖主键.唯一性 。一个表只说明一个事物； 
3. 第三范式：非主键字段不能相互依赖。
## InnoDB 和 MyISAM 的比较？
1. 事务：MyISAM不支持事务，InnoDB支持事务；
2. 全文索引：MyISAM 支持全文索引，InnoDB 5.6 之前不支持全文索引；
3. 关于 count()：MyISAM会直接存储总行数，InnoDB 则不会，需要按行扫描。意思就是对于 select count() from table; 如果数据量大，MyISAM 会瞬间返回，而 InnoDB 则会一行行扫描；
4. 外键：MyISAM 不支持外键，InnoDB 支持外键；
5. 锁：MyISAM 只支持表锁，InnoDB 可以支持行锁。
## 事务四大特性（ACID）原子性、一致性、隔离性、持久性？
1. 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚
2. 一致性（Consistency）事务开始前和结束后，数据库的完整性约束没有被破坏。
3. 隔离性（Isolation）当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
4. 持久性（Durability）持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
## 数据库如何保证一致性undo log？
undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 SQL语句，他需要记录你要回滚的相应日志信息。undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
## 数据库如何保证持久性redo log？
决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。
## char 和 varchar 的区别？
1. char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。
2. char的存取数度还是要比varchar要快得多
3. char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。要权衡。
## SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？
内连接：只有两个元素表相匹配的才能在结果集中显示。 
外连接： 
左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 
右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 
全外连接：连接的表中不匹配的数据全部会显示出来。 
交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。
# 索引
## 什么是聚合索引 ？
聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。
**聚簇索引和非聚簇索引的区别：**
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。
## MySQL中有哪些索引？有什么特点？
- **普通索引**：仅加速查询
- **唯一索引**：加速查询 + 列值唯一（可以有null）
- **主键索引**：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
- **组合索引**：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- **全文索引**：对文本的内容进行分词，进行搜索
- **索引合并**：使用多个单列索引组合搜索
- **覆盖索引**：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖
- **聚簇索引**：表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)
# 并发
## 分库和分表
分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。
- **通过分表** 
1. 可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用
2. 很大的缓解表锁的问题
__分表策略__ **垂直拆分和水平拆分** 
1. 水平切分 
水平切分是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。
2. 垂直切分
垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。例如：将原来的电商数据库垂直切分成商品数据库、用户数据库等。
取模分表就属于随机分表，而时间维度分表则属于连续分表。 如何设计好垂直拆分，我的建议：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。 对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。
- **库内分表** 
仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。
**分库与分表带来的分布式困境与应对之策**  数据迁移与扩容问题----一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。 分页与排序问题----需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。

## 不可重复读和幻读区别
**不可重复读的重点是修改，幻读的重点在于新增或者删除。**
- 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。
- 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就变为了5条，这样就导致了幻读。
## 说一下 MySQL 的行锁和表锁？
MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。
**表级锁：**开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。
**行级锁：**开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高
MySQL的行锁是通过索引加载的，行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁，此时其它事务无法对当前表进行更新或插入操作。insert，delete，update在事务中都会自动默认加上排它锁。


# 情景题
## MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？
设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
选择合适的表字段数据类型和存储引擎，适当的添加索引。
MySQL库主从读写分离。
找规律分表，减少单表中的数据量提高查询速度。
添加缓存机制，比如Memcached，Apc等。
不经常改动的页面，生成静态页面。
书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。
## 数据库结构优化的手段？
- **范式优化**： 比如消除冗余（节省空间。。）
- **反范式优化**：比如适当加冗余等（减少join）
- **限定数据的范围**： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。
- **读/写分离**： 经典的数据库拆分方案，主库负责写，从库负责读；
- **拆分表**：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。
## 数据库如何保证一致性undo log？
